//   Ordt 190725.01 autogenerated file 
//   Input: ./rdl_write_enable/test.rdl
//   Parms: ./rdl_write_enable/test.parms
//   Date: Sun Nov 17 17:09:00 EST 2019
//

import uvm_pkg::*;
import ordt_uvm_reg_pkg::*;

// Register intr_reg
class reg_foo_intr_reg extends uvm_reg_rdl;
  string m_rdl_tag;
  rand uvm_reg_field_rdl_counter count_fld;
  rand uvm_reg_field_rdl_interrupt intr1;
  rand uvm_reg_field_rdl_interrupt intr2;
  
  function new(string name = "reg_foo_intr_reg");
    super.new(name, 32, UVM_NO_COVERAGE);
  endfunction: new
  
  virtual function void build();
    string rdl_reg_name;
    this.count_fld = new("count_fld");
    this.count_fld.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.count_fld.add_incr(1, "", "", 0);
    this.count_fld.configure(this, 8, 0, "RW", 1, 8'h55, 1, 1, 0);
    this.intr1 = new("intr1");
    this.intr1.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.intr1.add_intr(0, 0, "", 0);
    this.intr1.configure(this, 1, 8, "RW", 1, 1'h0, 1, 1, 0);
    this.intr2 = new("intr2");
    this.intr2.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.intr2.add_intr(0, 0, "", 0);
    this.intr2.configure(this, 1, 9, "RW", 1, 1'h0, 1, 1, 0);
    
    rdl_reg_name = get_rdl_name("rg_");
    add_hdl_path_slice({rdl_reg_name, "count_fld"}, 0, 8);
    add_hdl_path_slice({rdl_reg_name, "intr1"}, 8, 1);
    add_hdl_path_slice({rdl_reg_name, "intr2"}, 9, 1);
  endfunction: build
  
  virtual function void get_intr_fields(ref uvm_reg_field fields[$]); // return all source interrupt fields
    uvm_reg_field f[$];
    uvm_reg_field_rdl rdl_f;
    uvm_reg_field_rdl_interrupt rdl_intr_f;
    get_fields(f);
    foreach(f[i]) begin
      $cast(rdl_f, f[i]);
      if (rdl_f.is_interrupt()) begin
        $cast(rdl_intr_f, rdl_f);
        rdl_intr_f.get_intr_fields(fields);
      end
    end
  endfunction: get_intr_fields
  
  virtual task get_active_intr_fields(ref uvm_reg_field fields[$], input bit is_halt, input uvm_path_e path = UVM_DEFAULT_PATH); // return all active source intr/halt fields
    uvm_reg_field f[$];
    uvm_reg_field_rdl rdl_f;
    uvm_reg_field_rdl_interrupt rdl_intr_f;
    uvm_status_e status;
    uvm_reg_data_t value;
    read(status, value, path);
    get_fields(f);
    foreach(f[i]) begin
      $cast(rdl_f, f[i]);
      if (rdl_f.is_interrupt() && rdl_f.get()) begin
        $cast(rdl_intr_f, rdl_f);
        rdl_intr_f.get_active_intr_fields(fields, is_halt, path);
      end
    end
  endtask: get_active_intr_fields
  
endclass : reg_foo_intr_reg

// Register log_reg
class reg_foo_log_reg extends uvm_reg_rdl;
  string m_rdl_tag;
  rand uvm_reg_field_rdl log_err;
  rand uvm_reg_field_rdl log_value;
  
  function new(string name = "reg_foo_log_reg");
    super.new(name, 32, UVM_NO_COVERAGE);
  endfunction: new
  
  virtual function void build();
    string rdl_reg_name;
    this.log_err = new("log_err");
    this.log_err.set_rdl_access_info(1, 1, 0, 1, 0, 0);
    this.log_err.configure(this, 8, 0, "RW", 1, 8'h4, 1, 1, 0);
    this.log_value = new("log_value");
    this.log_value.set_rdl_access_info(1, 0, 0, 1, 0, 0);
    this.log_value.configure(this, 8, 8, "RO", 1, 8'h0, 1, 0, 0);
    
    rdl_reg_name = get_rdl_name("rg_");
    add_hdl_path_slice({rdl_reg_name, "log_err"}, 0, 8);
    add_hdl_path_slice({rdl_reg_name, "log_value"}, 8, 8);
  endfunction: build
  
endclass : reg_foo_log_reg

// Register bigreg
class reg_foo_bigreg extends uvm_reg_rdl;
  string m_rdl_tag;
  rand uvm_reg_field_rdl field64;
  
  function new(string name = "reg_foo_bigreg");
    super.new(name, 64, UVM_NO_COVERAGE);
  endfunction: new
  
  virtual function void build();
    string rdl_reg_name;
    this.field64 = new("field64");
    this.field64.set_rdl_access_info(1, 1, 0, 0, 0, 0);
    this.field64.configure(this, 64, 0, "RW", 0, 64'h0, 1, 1, 1);
    
    rdl_reg_name = get_rdl_name("rg_");
    add_hdl_path_slice({rdl_reg_name, "field64"}, 0, 64);
  endfunction: build
  
endclass : reg_foo_bigreg

// Register array_reg
class reg_foo_childmap_32b_array_reg extends uvm_reg_rdl;
  string m_rdl_tag;
  rand uvm_reg_field_rdl field32;
  
  function new(string name = "reg_foo_childmap_32b_array_reg");
    super.new(name, 32, UVM_NO_COVERAGE);
  endfunction: new
  
  virtual function void build();
    string rdl_reg_name;
    this.field32 = new("field32");
    this.field32.set_rdl_access_info(1, 1, 0, 0, 0, 0);
    this.field32.configure(this, 32, 0, "RW", 0, 32'h0, 1, 1, 1);
    
    rdl_reg_name = get_rdl_name("rg_");
    add_hdl_path_slice({rdl_reg_name, "field32"}, 0, 32);
  endfunction: build
  
endclass : reg_foo_childmap_32b_array_reg

// Block childmap_32b
class block_foo_childmap_32b extends uvm_reg_block_rdl;
  rand reg_foo_childmap_32b_array_reg array_reg[8];
  
  function new(string name = "block_foo_childmap_32b");
    super.new(name);
  endfunction: new
  
  virtual function void build();
    this.default_map = create_map("", 0, 8, UVM_LITTLE_ENDIAN, 1);
    foreach (this.array_reg[i]) begin
      this.array_reg[i] = new($psprintf("array_reg [%0d]",i));
      this.array_reg[i].configure(this, null, "");
      this.array_reg[i].set_rdl_tag($psprintf("array_reg_%0d_",i));
      this.array_reg[i].set_reg_test_info(0, 0, 0);
      this.array_reg[i].build();
      this.default_map.add_reg(this.array_reg[i], `UVM_REG_ADDR_WIDTH'h0+i*`UVM_REG_ADDR_WIDTH'h4, "RW", 0);
    end
  endfunction: build
  
  `uvm_object_utils(block_foo_childmap_32b)
endclass : block_foo_childmap_32b

// Base block
class block_foo extends uvm_reg_block_rdl;
  rand reg_foo_intr_reg intr_reg;
  rand reg_foo_log_reg log_reg;
  rand reg_foo_bigreg bigreg;
  rand block_foo_childmap_32b childmap_32b;
  
  function new(string name = "block_foo");
    super.new(name);
  endfunction: new
  
  virtual function void build();
    this.default_map = create_map("", `UVM_REG_ADDR_WIDTH'h0, 8, UVM_LITTLE_ENDIAN, 1);
    this.set_rdl_address_map(1);
    this.set_rdl_address_map_hdl_path({`FOO_PIO_INSTANCE_PATH, ".pio_logic"});
    this.intr_reg = new("intr_reg");
    this.intr_reg.configure(this, null, "");
    this.intr_reg.set_rdl_tag("intr_reg_");
    this.intr_reg.set_reg_test_info(0, 0, 0);
    this.intr_reg.build();
    this.default_map.add_reg(this.intr_reg, `UVM_REG_ADDR_WIDTH'h0, "RW", 0);
    this.log_reg = new("log_reg");
    this.log_reg.configure(this, null, "");
    this.log_reg.set_rdl_tag("log_reg_");
    this.log_reg.set_reg_test_info(0, 0, 32);
    this.log_reg.build();
    this.default_map.add_reg(this.log_reg, `UVM_REG_ADDR_WIDTH'h4, "RW", 0);
    this.bigreg = new("bigreg");
    this.bigreg.configure(this, null, "");
    this.bigreg.set_rdl_tag("bigreg_");
    this.bigreg.set_reg_test_info(0, 0, 0);
    this.bigreg.build();
    this.default_map.add_reg(this.bigreg, `UVM_REG_ADDR_WIDTH'h8, "RW", 0);
    this.childmap_32b = block_foo_childmap_32b::type_id::create("childmap_32b",, get_full_name());
    this.childmap_32b.configure(this, "");
    this.childmap_32b.set_rdl_address_map(1);
    this.childmap_32b.set_rdl_address_map_hdl_path({`FOO_CHILDMAP_32B_PIO_INSTANCE_PATH, ".pio_logic"});
    this.childmap_32b.set_rdl_tag("childmap_32b_");
    this.childmap_32b.build();
    this.default_map.add_submap(this.childmap_32b.default_map, `UVM_REG_ADDR_WIDTH'h100);
    this.add_callbacks();
  endfunction: build
  
  `uvm_object_utils(block_foo)
endclass : block_foo
