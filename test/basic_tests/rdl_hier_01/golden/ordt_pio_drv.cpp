//   Ordt 190725.01 autogenerated file 
//   Input: ./rdl_hier_01/test.rdl
//   Parms: ./rdl_hier_01/test.parms
//   Date: Sun Nov 17 17:09:27 EST 2019
//

#include "ordt_pio_common.hpp"
#include "ordt_pio_drv.hpp"

// ------------------ ordt_drv_path_element methods ------------------

ordt_drv_path_element::ordt_drv_path_element(std::string _m_name, int _m_idx)
  : m_name(_m_name),
    m_idx(_m_idx) {
}

// ------------------ ordt_drv_field methods ------------------

ordt_drv_field::ordt_drv_field(std::string _m_name, int _m_loidx, int _m_width, bool _m_readable, bool _m_writeable)
  : m_name(_m_name),
    m_loidx(_m_loidx),
    m_width(_m_width),
    m_readable(_m_readable),
    m_writeable(_m_writeable) {
}

// ------------------ ordt_drv_element methods ------------------

std::list<std::string>  ordt_drv_element::split(const std::string &text, char sep, bool trim_rb) {
  std::list<std::string> tokens;
  std::size_t start = 0, end = 0, end_adj = 0;
  while ((end = text.find(sep, start)) != std::string::npos) {
    if (trim_rb && ((end_adj = text.find(']', start)) != std::string::npos) && (end_adj<end))
      tokens.push_back(text.substr(start, end_adj - start));
    else
      tokens.push_back(text.substr(start, end - start));
    start = end + 1;
  }
  if (trim_rb && ((end_adj = text.find(']', start)) != std::string::npos))
    tokens.push_back(text.substr(start, end_adj - start));
  else
    tokens.push_back(text.substr(start));
  return tokens;
}

int  ordt_drv_element::get_version(const std::string tag) {
  if (tag == "base_map") return 0;
  else return -1;
}

std::list<ordt_drv_path_element>  ordt_drv_element::get_path(const std::string pathstr) {
  std::list<ordt_drv_path_element> pathlist;
  std::list<std::string> lst = split(pathstr, '.', true);
  for(auto const& str_elem: lst) {
     std::list<std::string> sub_lst = split(str_elem, '[', false);
     if (sub_lst.size()==2) {
       pathlist.emplace_back(sub_lst.front(), std::stoi(sub_lst.back()));
     }
     else {
       pathlist.emplace_back(sub_lst.front(), 1);
     }
  }
  return pathlist;
}

ordt_drv_element::ordt_drv_element(std::string _m_name)
  : m_name(_m_name) {
}

int  ordt_drv_element::get_address_using_version(const int version, const std::string pathstr, uint64_t &address, std::list<ordt_drv_field> &fields) {
  std::list<ordt_drv_path_element> path = get_path(pathstr);
  if (path.size()>0) return get_address_using_list(version, path, false, address, fields);
  #ifdef ORDT_PIO_DRV_VERBOSE
     std::cout << "--> invalid path: " << pathstr << "\n";
  #endif
  return 4;
}

std::vector<std::string>  ordt_drv_element::get_tags() {
  std::vector<std::string> tags;
  tags.push_back("base_map");
  return tags;
}

int  ordt_drv_element::get_address(const std::string tag, const std::string pathstr, uint64_t &address, std::list<ordt_drv_field> &fields) {
  int version = get_version(tag);
  if (version<0) {
  #ifdef ORDT_PIO_DRV_VERBOSE
     std::cout << "--> invalid tag: " << tag << "\n";
  #endif
    return 2;
  }
  return get_address_using_version(version, pathstr, address, fields);
}

// ------------------ ordt_drv_regset_child methods ------------------

ordt_drv_regset_child::ordt_drv_regset_child(int _m_map, std::shared_ptr<ordt_drv_element> _m_child, int _m_reps, uint64_t _m_offset, uint64_t _m_stride)
  : m_map(_m_map),
    m_child(_m_child),
    m_reps(_m_reps),
    m_offset(_m_offset),
    m_stride(_m_stride) {
}

// ------------------ ordt_drv_regset methods ------------------

ordt_drv_regset::ordt_drv_regset(std::string _m_name)
  : ordt_drv_element(_m_name),
    m_children() {
}

int  ordt_drv_regset::get_address_using_list(const int version, std::list<ordt_drv_path_element> &path, const bool bypass_names, uint64_t &address, std::list<ordt_drv_field> &fields) {
  if (path.empty())
    return 8;
  ordt_drv_path_element pelem = path.front();
  if (!bypass_names) {
    path.pop_front();
    if (path.empty())
      return 0;
    pelem = path.front();
  }
  for (auto const &child: m_children) {
    if (((1<<version) & child.m_map) && (bypass_names || (pelem.m_name == child.m_child->m_name))) {
      address += child.m_offset;
      if (child.m_reps>1) address += (child.m_stride*pelem.m_idx);
      return child.m_child->get_address_using_list(version, path, false, address, fields);
    }
  }
  #ifdef ORDT_PIO_DRV_VERBOSE
  std::cout << "--> unable to find child " << pelem.m_name << " in regset " << m_name << "\n";
  #endif
  return 8;
}

void  ordt_drv_regset::add_child(int _m_map, std::shared_ptr<ordt_drv_element> _m_child, int _m_reps, uint64_t _m_offset, uint64_t _m_stride) {
  ordt_drv_regset_child new_child(_m_map, _m_child, _m_reps, _m_offset, _m_stride);
  m_children.push_back(new_child);
}

// ------------------ ordt_drv_reg methods ------------------

ordt_drv_reg::ordt_drv_reg(std::string _m_name)
  : ordt_drv_element(_m_name),
    m_fields() {
}

int  ordt_drv_reg::get_address_using_list(const int version, std::list<ordt_drv_path_element> &path, const bool bypass_names, uint64_t &address, std::list<ordt_drv_field> &fields) {
  if (path.empty())
    return 8;
  path.pop_front();
  if (path.empty()) {
    fields = m_fields;
    return 0;
  }
  #ifdef ORDT_PIO_DRV_VERBOSE
  ordt_drv_path_element pelem = path.front();
  std::cout << "--> invalid child " << pelem.m_name << " specified in reg " << m_name << "\n";
  #endif
  return 8;
}

void  ordt_drv_reg::add_field(std::string _m_name, int _m_loidx, int _width, bool _m_readable, bool _m_writeable) {
  ordt_drv_field new_field(_m_name, _m_loidx, _width, _m_readable, _m_writeable);
  m_fields.push_back(new_field);
}

// ------------------ ordt_drv_root methods ------------------

ordt_drv_root::ordt_drv_root()
  : ordt_drv_regset("root") {
  build();
}

void  ordt_drv_root::build() {
  std::shared_ptr<ordt_drv_reg> no_opt_reg_35 = std::make_shared<ordt_drv_reg>("no_opt_reg");
  no_opt_reg_35->add_field("lsb_field", 0, 16, true, false);
  std::shared_ptr<ordt_drv_reg> opt_reg_36 = std::make_shared<ordt_drv_reg>("opt_reg");
  opt_reg_36->add_field("lsb_field", 0, 16, true, false);
  std::shared_ptr<ordt_drv_reg> config_regs_2 = std::make_shared<ordt_drv_reg>("config_regs");
  config_regs_2->add_field("lsb_field", 0, 16, true, true);
  config_regs_2->add_field("msb_field", 16, 16, true, true);
  std::shared_ptr<ordt_drv_reg> state_regs_3 = std::make_shared<ordt_drv_reg>("state_regs");
  state_regs_3->add_field("lsb_field", 0, 16, true, false);
  std::shared_ptr<ordt_drv_regset> ext_base_regs_4 = std::make_shared<ordt_drv_regset>("ext_base_regs");
  ext_base_regs_4->add_child(1, config_regs_2, 8, 0, 4);
  ext_base_regs_4->add_child(1, state_regs_3, 8, 256, 4);
  std::shared_ptr<ordt_drv_regset> base_regs_1 = std::make_shared<ordt_drv_regset>("base_regs");
  base_regs_1->add_child(1, config_regs_2, 8, 0, 4);
  base_regs_1->add_child(1, state_regs_3, 8, 256, 4);
  std::shared_ptr<ordt_drv_regset> l3_child_14 = std::make_shared<ordt_drv_regset>("l3_child");
  l3_child_14->add_child(1, base_regs_1, 1, 0, 512);
  l3_child_14->add_child(1, ext_base_regs_4, 1, 2048, 512);
  std::shared_ptr<ordt_drv_regset> l2_r16_child_7 = std::make_shared<ordt_drv_regset>("l2_r16_child");
  l2_r16_child_7->add_child(1, ext_base_regs_4, 1, 4096, 512);
  l2_r16_child_7->add_child(1, base_regs_1, 1, 0, 512);
  l2_r16_child_7->add_child(1, l3_child_14, 1, 8192, 4096);
  std::shared_ptr<ordt_drv_regset> l2_s8_child_21 = std::make_shared<ordt_drv_regset>("l2_s8_child");
  l2_s8_child_21->add_child(1, ext_base_regs_4, 1, 4096, 512);
  l2_s8_child_21->add_child(1, base_regs_1, 1, 0, 512);
  l2_s8_child_21->add_child(1, l3_child_14, 1, 8192, 4096);
  std::shared_ptr<ordt_drv_regset> base_map_0 = std::make_shared<ordt_drv_regset>("base_map");
  base_map_0->add_child(1, no_opt_reg_35, 1, 262144, 4);
  base_map_0->add_child(1, opt_reg_36, 1, 262160, 4);
  base_map_0->add_child(1, l2_r16_child_7, 1, 131072, 16384);
  base_map_0->add_child(1, l2_s8_child_21, 1, 196608, 16384);
  base_map_0->add_child(1, base_regs_1, 1, 0, 512);
  base_map_0->add_child(1, ext_base_regs_4, 1, 65536, 512);
  add_child(1, base_map_0, 1, 0, 0);
}

int  ordt_drv_root::get_address_using_version(const int version, const std::string pathstr, uint64_t &address, std::list<ordt_drv_field> &fields) {
  address=0;
  fields.clear();
  std::list<ordt_drv_path_element> path = get_path(pathstr);
  if (path.size()>0) return get_address_using_list(version, path, true, address, fields);
  #ifdef ORDT_PIO_DRV_VERBOSE
     std::cout << "--> invalid path: " << pathstr << "\n";
  #endif
  return 4;
}

