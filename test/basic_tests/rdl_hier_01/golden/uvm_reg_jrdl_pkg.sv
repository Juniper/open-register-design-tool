//   Ordt 190725.01 autogenerated file 
//   Date: Sun Nov 17 17:08:46 EST 2019
//


// ordt_uvm_reg_pkg containing ordt extended classes
`ifndef ORDT_UVM_REG_PKG_SV
  `define ORDT_UVM_REG_PKG_SV
  `include "uvm_macros.svh"
  package ordt_uvm_reg_pkg;
    import uvm_pkg::*;
    
    typedef enum int unsigned {
      INTERRUPT = 64,
      DIAGNOSTIC = 128,
      CGATE_UNSAFE = 512,
      ERROR_COUNTER = 16,
      DYNAMIC_CONFIG = 2,
      STATIC_CONFIG = 1,
      CONSTRAINED_CONFIG = 4,
      STATE = 32,
      DEBUG = 256,
      STAT_COUNTER = 8
    } js_category_e;
    
    typedef enum int unsigned {
      MAJOR = 2,
      MINOR_TRANSIENT = 16,
      INFO = 1,
      FATAL = 4,
      MINOR_RECOVERABLE = 8
    } js_subcategory_e;
    
    // uvm_reg_block_rdl class
    class uvm_reg_block_rdl extends uvm_reg_block;
      string m_rdl_tag;
      bit m_rdl_address_map = 0;
      string m_rdl_address_map_hdl_path = "";
      local string m_def_properties[ string ];
      
      function new(string name = "uvm_reg_block_rdl", int has_coverage = UVM_NO_COVERAGE);
        super.new(name, has_coverage);
      endfunction: new
      
      /* Set indication that this block represents an rdl addrmap. */
      function void set_rdl_address_map(bit val = 0);
        m_rdl_address_map = val;
      endfunction: set_rdl_address_map
      
      /* Set the root hdl path to the address map module that this block represents. */
      function void set_rdl_address_map_hdl_path(string path = "");
        m_rdl_address_map_hdl_path = path;
        this.set_hdl_path_root(path);
      endfunction: set_rdl_address_map_hdl_path
      
      /* Set the rdl tag string for this block.  The tag will be used to build
       * RTL signal names using the model hierarchy. */
      function void set_rdl_tag(string rdl_tag = "rdl_tag");
        m_rdl_tag = rdl_tag;
      endfunction: set_rdl_tag
      
      /* Return a string corresponding to this model element using recursive call to
       * ancestors (stopping at an address map).  Used to generate RTL signal names. */
      function string get_rdl_name(string prefix, bit add_hdl_prefix = 0, string override_tag = "");
        uvm_reg_block_rdl rdl_parent;
        string rdl_tag;
        if (override_tag.len() > 0)
          rdl_tag = override_tag;
        else
          rdl_tag = m_rdl_tag;
        if (m_rdl_address_map) begin
          if (add_hdl_prefix)
            return {m_rdl_address_map_hdl_path, ".", prefix, rdl_tag};
          else
            return {prefix, rdl_tag};
        end
        if (get_parent() != null) begin
          $cast(rdl_parent, get_parent());
          return {rdl_parent.get_rdl_name(prefix, add_hdl_prefix, override_tag), rdl_tag};
        end
        return rdl_tag;
      endfunction: get_rdl_name
      
      /* Null function that is overridden by block/reg classes requiring callback setup. */
      virtual function void add_callbacks();
      endfunction: add_callbacks
      
      /* Return the uvm_reg_block_rdl element that is the specified number of ancestor
       * levels from the current block/register. */
      virtual function uvm_reg_block_rdl get_ancestor(int depth);
        uvm_reg_block_rdl rdl_parent;
        $cast(rdl_parent, get_parent());
        if (depth < 2) return rdl_parent;
        else return rdl_parent.get_ancestor(depth-1);
      endfunction: get_ancestor
      
      /* Add a user-defined property to this rdl class instance */
      function void add_def_property(string name, string value);
        m_def_properties[name] = value;
      endfunction: add_def_property
      
      /* Returns 1 if a user-defined property of specified name exists for this rdl class instance */
      function bit has_def_property(string name);
        return m_def_properties.exists(name);
      endfunction: has_def_property
      
      /* Returns a user-defined property of specified name for this rdl class instance */
      function string get_def_property(string name);
        return m_def_properties[name];
      endfunction: get_def_property
      
      /* Removes the user-defined property of specified name for this rdl class instance */
      function void remove_def_property(string name);
        m_def_properties.delete(name);
      endfunction: remove_def_property
      
      `uvm_object_utils(uvm_reg_block_rdl)
    endclass : uvm_reg_block_rdl
    
    // uvm_reg_rdl class
    class uvm_reg_rdl extends uvm_reg;
      local string m_rdl_tag;
      local bit m_external = 0;
      local bit m_dont_test = 0;
      local bit m_dont_compare = 0;
      local int unsigned m_js_category = 0;
      local string m_def_properties[ string ];
      
      function new(string name = "uvm_reg_rdl", int unsigned n_bits = 0, int has_coverage = UVM_NO_COVERAGE);
        super.new(name, n_bits, has_coverage);
      endfunction: new
      
      /* Set the rdl tag string for this register.  The tag will be used to build
       * RTL signal names using the model hierarchy. */
      function void set_rdl_tag(string rdl_tag = "rdl_tag");
        m_rdl_tag = rdl_tag;
      endfunction: set_rdl_tag
      
      /* Return a string corresponding to this model element using recursive call to
       * ancestors.  Used to generate RTL signal names.
       * RTL signal names using the model hierarchy. */
      function string get_rdl_name(string prefix, bit add_hdl_prefix = 0, string override_tag = "");
        uvm_reg_block_rdl rdl_parent;
        string rdl_tag;
        if (override_tag.len() > 0)
          rdl_tag = override_tag;
        else
          rdl_tag = m_rdl_tag;
        if (get_parent() != null) begin
          $cast(rdl_parent, get_parent());
          return {rdl_parent.get_rdl_name(prefix, add_hdl_prefix, override_tag), rdl_tag};
        end
        return rdl_tag;
      endfunction: get_rdl_name
      
      /* Add a user-defined property to this rdl class instance */
      function void add_def_property(string name, string value);
        m_def_properties[name] = value;
      endfunction: add_def_property
      
      /* Returns 1 if a user-defined property of specified name exists for this rdl class instance */
      function bit has_def_property(string name);
        return m_def_properties.exists(name);
      endfunction: has_def_property
      
      /* Returns a user-defined property of specified name for this rdl class instance */
      function string get_def_property(string name);
        return m_def_properties[name];
      endfunction: get_def_property
      
      /* Removes the user-defined property of specified name for this rdl class instance */
      function void remove_def_property(string name);
        m_def_properties.delete(name);
      endfunction: remove_def_property
      
      /* Set indication that this register is external to autogenerated logic. */
      function void set_external(bit is_external);
        m_external = is_external;
      endfunction: set_external
      
      /* Return 1 if this register is external to autogenerated logic. */
      function bit is_external();
        return m_external;
      endfunction: is_external
      
      /* Return a list of all leaf fields in this register's interrupt hierarchy.
       * This null function is overridden by child interrupt register classes. */
      virtual function void get_intr_fields(ref uvm_reg_field fields[$]);
      endfunction: get_intr_fields
      
      /* Return a list of all fields in this register's interrupt hierarchy that are causing
       * halt or interrupt to be asserted.  This null task is overridden by child interrupt register classes. */
      virtual task get_active_intr_fields(ref uvm_reg_field fields[$], input bit is_halt, input uvm_path_e path = UVM_DEFAULT_PATH);
      endtask: get_active_intr_fields
      
      /* Set test related info for this register (donttest, dontcompare, js category). */
      function void set_reg_test_info(bit dont_test, bit dont_compare, int js_category);
        m_dont_test = dont_test;
        m_dont_compare = dont_compare;
        m_js_category = js_category;
      endfunction: set_reg_test_info
      
      /* Return 1 if register is marked don't test. */
      function bit is_dont_test();
        return m_dont_test;
      endfunction: is_dont_test
      
      /* Return 1 if register is marked don't compare. */
      function bit is_dont_compare();
        return m_dont_compare;
      endfunction: is_dont_compare
      
      /* Return 1 if register has a jspec category. */
      function bit has_a_js_category();
        return (m_js_category > 0);
      endfunction: has_a_js_category
      
      /* Return 1 if register has the specified jspec category. */
      function bit has_js_category(js_category_e cat);
        return ((cat & m_js_category) > 0);
      endfunction: has_js_category
      
      /* Add the specified jspec category to this register. */
      function void add_js_category(js_category_e cat);
        m_js_category = m_js_category | cat;
      endfunction: add_js_category
      
      /* Remove the specified jspec category from this register. */
      function void remove_js_category(js_category_e cat);
        m_js_category = m_js_category & ~cat;
      endfunction: remove_js_category
      
      /* Null function that is overridden by block/reg classes requiring callback setup. */
      virtual function void add_callbacks();
      endfunction: add_callbacks
      
      /* Return the uvm_reg_block_rdl element that is the specified number of ancestor
       * levels from the current block/register. */
      virtual function uvm_reg_block_rdl get_ancestor(int depth);
        uvm_reg_block_rdl rdl_parent;
        $cast(rdl_parent, get_parent());
        if (depth < 2) return rdl_parent;
        else return rdl_parent.get_ancestor(depth-1);
      endfunction: get_ancestor
      
    endclass : uvm_reg_rdl
    
    // uvm_vreg_rdl class
    class uvm_vreg_rdl extends uvm_vreg;
      local bit m_dont_test = 0;
      local bit m_dont_compare = 0;
      local int unsigned m_js_category = 0;
      local bit m_has_reset = 0;
      local uvm_reg_data_t m_reset_value;
      local uvm_reg_data_t m_staged[longint unsigned];
      local string m_def_properties[ string ];
      
      function new(string name = "uvm_vreg_rdl", int unsigned n_bits = 0);
        super.new(name, n_bits);
      endfunction: new
      
      /* Set test related info for this register (donttest, dontcompare, js category). */
      function void set_reg_test_info(bit dont_test, bit dont_compare, int js_category);
        m_dont_test = dont_test;
        m_dont_compare = dont_compare;
        m_js_category = js_category;
      endfunction: set_reg_test_info
      
      /* Return 1 if register is marked don't test. */
      function bit is_dont_test();
        return m_dont_test;
      endfunction: is_dont_test
      
      /* Return 1 if register is marked don't compare. */
      function bit is_dont_compare();
        return m_dont_compare;
      endfunction: is_dont_compare
      
      /* Return 1 if register has a jspec category. */
      function bit has_a_js_category();
        return (m_js_category > 0);
      endfunction: has_a_js_category
      
      /* Return 1 if register has the specified jspec category. */
      function bit has_js_category(js_category_e cat);
        return ((cat & m_js_category) > 0);
      endfunction: has_js_category
      
      /* Add the specified jspec category to this register. */
      function void add_js_category(js_category_e cat);
        m_js_category = m_js_category | cat;
      endfunction: add_js_category
      
      /* Remove the specified jspec category from this register. */
      function void remove_js_category(js_category_e cat);
        m_js_category = m_js_category & ~cat;
      endfunction: remove_js_category
      
      /* Add a user-defined property to this rdl class instance */
      function void add_def_property(string name, string value);
        m_def_properties[name] = value;
      endfunction: add_def_property
      
      /* Returns 1 if a user-defined property of specified name exists for this rdl class instance */
      function bit has_def_property(string name);
        return m_def_properties.exists(name);
      endfunction: has_def_property
      
      /* Returns a user-defined property of specified name for this rdl class instance */
      function string get_def_property(string name);
        return m_def_properties[name];
      endfunction: get_def_property
      
      /* Removes the user-defined property of specified name for this rdl class instance */
      function void remove_def_property(string name);
        m_def_properties.delete(name);
      endfunction: remove_def_property
      
      /* Return 1 if a reset value exists for this vreg set. */
      function bit has_reset_value();
        return m_has_reset;
      endfunction: has_reset_value
      
      /* Return the reset value for this vreg set. */
      function uvm_reg_data_t get_reset_value();
        return m_reset_value;
      endfunction: get_reset_value
      
      /* Set the reset value for each register in this vreg set. */
      function void set_reset_value(uvm_reg_data_t reset_value);
        m_has_reset = 1;
        m_reset_value = reset_value;
      endfunction: set_reset_value
      
      /* Return the value at the specified stage array idx. If no valid data exists at specified index,
       * the reset value associated with this vreg will be returned.  If no reset value exists, a uvm_error
       * will be thrown. */
      function uvm_reg_data_t get_staged(longint unsigned stage_idx);
        if (m_staged.exists(stage_idx)) return m_staged[stage_idx];
        else if (has_reset_value()) return m_reset_value;
        `uvm_error("RegModel", $sformatf("Accessing uninitialized staged value at index %d. (uvm_vreg_rdl::get_staged())", stage_idx));
        return 0;
      endfunction: get_staged
      
      /* Return the value of the field with specified name at a given stage array idx. */
      function uvm_reg_data_t get_staged_field(longint unsigned stage_idx, string name);
        uvm_reg_data_t rvalue;
        uvm_vreg_field vfld;
        int unsigned lsb;
        int unsigned fsize;
        vfld = this.get_field_by_name(name);
        if (vfld == null) begin;
          `uvm_error("RegModel", $sformatf("Unable to find field \"%s\" specified in uvm_vreg_rdl::get_staged_data()", name));
          return 0;
        end
        lsb = vfld.get_lsb_pos_in_register();
        fsize = vfld.get_n_bits();
        rvalue = get_staged(stage_idx);
        return (rvalue & (((1<<fsize)-1) << lsb)) >> lsb;
      endfunction: get_staged_field
      
      /* Set the value stored at the specified stage array idx. */
      function void set_staged(longint unsigned stage_idx, uvm_reg_data_t staged);
        m_staged[stage_idx] = staged;
      endfunction: set_staged
      
      /* Set the value of the field with specified name stored at a given stage array idx.
       * Other bit locations in the target stage array location are not modified. */
      function void stage_field(longint unsigned stage_idx, string name, uvm_reg_data_t value);
        uvm_vreg_field vfld;
        int unsigned lsb;
        int unsigned fsize;
        vfld = this.get_field_by_name(name);
        if (vfld == null) begin;
          `uvm_error("RegModel", $sformatf("Unable to find field \"%s\" specified in uvm_vreg_rdl::stage_field()", name));
          return;
        end
        lsb = vfld.get_lsb_pos_in_register();
        fsize = vfld.get_n_bits();
        if (value >> fsize) begin
          `uvm_warning("RegModel", $sformatf("Staging value 'h%h that is greater than field \"%s\" size (%0d bits)", value, name, fsize));
          value &= ((1<<fsize)-1);
        end
        if (!m_staged.exists(stage_idx)) begin
          if (has_reset_value()) m_staged[stage_idx] = m_reset_value;
          else m_staged[stage_idx] = 0;
        end
        m_staged[stage_idx] |= (((1<<fsize)-1) << lsb);
        m_staged[stage_idx] ^= (((1<<fsize)-1) << lsb);
        m_staged[stage_idx] |= (value << lsb);
      endfunction: stage_field
      
      /* Write the stage array value stored at stage_idx to dut memory at offset vreg_idx */
      virtual task write_staged(input longint unsigned stage_idx, input longint unsigned vreg_idx, output uvm_status_e status, input uvm_path_e path = UVM_DEFAULT_PATH, input uvm_reg_map map = null, input uvm_sequence_base parent = null, input uvm_object extension = null, input string fname = "", input int lineno = 0);
        if (!m_staged.exists(stage_idx)) begin
          `uvm_error("RegModel", $sformatf("Attempting write of uninitialized staged value at index %d. (uvm_vreg_rdl::write_staged())", stage_idx));
          return;
        end
        this.write(vreg_idx, status, m_staged[stage_idx], path, map, parent, extension, fname, lineno);
      endtask: write_staged
      
      /* Write the stage array value stored at idx to dut memory at same idx offset */
      virtual task write_same_staged(input longint unsigned idx, output uvm_status_e status, input uvm_path_e path = UVM_DEFAULT_PATH, input uvm_reg_map map = null, input uvm_sequence_base parent = null, input uvm_object extension = null, input string fname = "", input int lineno = 0);
        this.write_staged(idx, idx, status, path, map, parent, extension, fname, lineno);
      endtask: write_same_staged
      
    endclass : uvm_vreg_rdl
    
    // derived rdl field class 
    class uvm_reg_field_rdl extends uvm_reg_field;
      protected bit m_is_counter = 0;
      protected bit m_is_interrupt = 0;
      protected bit m_is_dontcompare = 0;
      local bit m_is_sw_readable = 1;
      local bit m_is_sw_writeable = 1;
      local bit m_is_hw_readable = 1;
      local bit m_is_hw_writeable = 0;
      local bit m_has_hw_we = 0;
      local bit m_has_hw_wel = 0;
      local bit m_is_unsupported = 0;
      local int unsigned m_js_subcategory = 0;
      local string m_def_properties[ string ];
      
      function new(string name = "uvm_reg_field_rdl");
        super.new(name);
      endfunction: new
      
      /* Add a user-defined property to this rdl class instance */
      function void add_def_property(string name, string value);
        m_def_properties[name] = value;
      endfunction: add_def_property
      
      /* Returns 1 if a user-defined property of specified name exists for this rdl class instance */
      function bit has_def_property(string name);
        return m_def_properties.exists(name);
      endfunction: has_def_property
      
      /* Returns a user-defined property of specified name for this rdl class instance */
      function string get_def_property(string name);
        return m_def_properties[name];
      endfunction: get_def_property
      
      /* Removes the user-defined property of specified name for this rdl class instance */
      function void remove_def_property(string name);
        m_def_properties.delete(name);
      endfunction: remove_def_property
      
      /* Return the uvm_reg_rdl parent of this field. */
      function uvm_reg_rdl get_rdl_register();
        uvm_reg_rdl rdl_reg;
        $cast(rdl_reg, get_register());
        return rdl_reg;
      endfunction: get_rdl_register
      
      /* Set rdl hw/sw access info for this field. */
      function void set_rdl_access_info(bit is_sw_readable, bit is_sw_writeable, bit is_hw_readable, bit is_hw_writeable, bit has_hw_we, bit has_hw_wel);
        m_is_sw_readable = is_sw_readable;
        m_is_sw_writeable = is_sw_writeable;
        m_is_hw_readable = is_hw_readable;
        m_is_hw_writeable = is_hw_writeable;
        m_has_hw_we = has_hw_we;
        m_has_hw_wel = has_hw_wel;
      endfunction: set_rdl_access_info
      
      /* Return the name of the read data output signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_hw_read_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("l2h_", 1), this.get_name(), "_r"};
      endfunction: get_hw_read_signal
      
      /* Return the name of the write data input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_hw_write_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("h2l_", 1), this.get_name(), "_w"};
      endfunction: get_hw_write_signal
      
      /* Return the name of the active high write enable input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_hw_we_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("h2l_", 1), this.get_name(), "_we"};
      endfunction: get_hw_we_signal
      
      /* Return the name of the active low write enable input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_hw_wel_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("h2l_", 1), this.get_name(), "_wel"};
      endfunction: get_hw_wel_signal
      
      /* Returns 1 if this field can be read by sw. */
      function bit is_sw_readable();
        return m_is_sw_readable;
      endfunction: is_sw_readable
      
      /* Returns 1 if this field can be written by sw. */
      function bit is_sw_writeable();
        return m_is_sw_writeable;
      endfunction: is_sw_writeable
      
      /* Returns 1 if this field can be read by hw. */
      function bit is_hw_readable();
        return m_is_hw_readable;
      endfunction: is_hw_readable
      
      /* Returns 1 if this field can be written by hw. */
      function bit is_hw_writeable();
        return m_is_hw_writeable;
      endfunction: is_hw_writeable
      
      /* Returns 1 if this field has an active high hw write enable. */
      function bit has_hw_we();
        return m_has_hw_we;
      endfunction: has_hw_we
      
      /* Returns 1 if this field has an active low hw write enable. */
      function bit has_hw_wel();
        return m_has_hw_wel;
      endfunction: has_hw_wel
      
      /* Returns 1 if this field is a counter.  It is assumed this class can be cast to
       * uvm_reg_field_rdl_counter if this value is set. */
      function bit is_counter();
        return m_is_counter;
      endfunction: is_counter
      
      /* Returns 1 if this field is an interrupt.  It is assumed this class can be cast to
       * uvm_reg_field_rdl_interrupt if this value is set. */
      function bit is_interrupt();
        return m_is_interrupt;
      endfunction: is_interrupt
      
      /* Sets indication that this field has functionality that is unsupported in the uvm model (use tbd). */
      function void set_unsupported();
        m_is_unsupported = 1;
      endfunction: set_unsupported
      
      /* Returns 1 if this field has functionality that is unsupported in the uvm model (use tbd). */
      function bit is_unsupported();
        return m_is_unsupported;
      endfunction: is_unsupported
      
      /* Sets the dontcompare indicator on this field. */
      function void set_dontcompare();
        m_is_dontcompare = 1;
      endfunction: set_dontcompare
      
      /* Returns 1 if this field has dontcompare set. */
      function bit is_dontcompare();
        return m_is_dontcompare;
      endfunction: is_dontcompare
      
      /* Returns 1 if this field has a jspec subcategory. */
      function bit has_a_js_subcategory();
        return (m_js_subcategory > 0);
      endfunction: has_a_js_subcategory
      
      /* Returns 1 if this field has the specified jspec subcategory. */
      function bit has_js_subcategory(js_subcategory_e cat);
        return ((cat & m_js_subcategory) > 0);
      endfunction: has_js_subcategory
      
      /* Sets the specified jspec subcategory for this field. */
      function void add_js_subcategory(js_subcategory_e cat);
        m_js_subcategory = m_js_subcategory | cat;
      endfunction: add_js_subcategory
      
      /* Removes the specified jspec subcategory for this field. */
      function void remove_js_subcategory(js_subcategory_e cat);
        m_js_subcategory = m_js_subcategory & ~cat;
      endfunction: remove_js_subcategory
      
      /* Sets the specified set of encoded jspec subcategories for this field. */
      function void set_js_subcategory(int js_subcategory);
        m_js_subcategory = js_subcategory;
      endfunction: set_js_subcategory
      
    endclass : uvm_reg_field_rdl
    
    // counter field class 
    class uvm_reg_field_rdl_counter extends uvm_reg_field_rdl;
      local uvm_reg_data_t m_accum_value = 0;
      local string m_incr_sig;
      local uvm_reg_data_t m_incr_value = 1;
      local string m_incr_value_sig;
      local int unsigned m_incr_value_sig_width = 0;
      local bit m_has_incr_sat = 0;
      local uvm_reg_data_t m_incr_sat_value = 0;
      local string m_incr_sat_value_sig;
      local bit m_has_incr_thold = 0;
      local uvm_reg_data_t m_incr_thold_value = 0;
      local string m_incr_thold_value_sig;
      local string m_decr_sig;
      local uvm_reg_data_t m_decr_value = 1;
      local string m_decr_value_sig;
      local int unsigned m_decr_value_sig_width = 0;
      local bit m_has_decr_sat = 0;
      local uvm_reg_data_t m_decr_sat_value = 0;
      local string m_decr_sat_value_sig;
      local bit m_has_decr_thold = 0;
      local uvm_reg_data_t m_decr_thold_value = 0;
      local string m_decr_thold_value_sig;
      
      function new(string name = "uvm_reg_field_rdl_counter");
        super.new(name);
      endfunction: new
      
      /* Return the scratchpad data stored for this counter field. */
      function uvm_reg_data_t get_accum_value();
        return m_accum_value;
      endfunction: get_accum_value
      
      /* Set the scratchpad data value for this counter field. */
      function void set_accum_value(uvm_reg_data_t accum_value);
        m_accum_value = accum_value;
      endfunction: set_accum_value
      
      /* Set incrementing counter info for this field. */
      function void add_incr(uvm_reg_data_t incr_value, string incr_sig = "", string incr_value_sig = "", int unsigned incr_value_sig_width = 0);
        m_is_counter = 1;
        m_incr_value = incr_value;
        if (incr_sig.len() > 0) m_incr_sig = incr_sig;
        if (incr_value_sig.len() > 0) m_incr_value_sig = incr_value_sig;
        m_incr_value_sig_width = incr_value_sig_width;
      endfunction: add_incr
      
      /* Set incrementing counter saturation value info for this field. */
      function void add_incr_sat(uvm_reg_data_t incr_sat_value, string incr_sat_value_sig = "");
        m_has_incr_sat = 1;
        m_incr_sat_value = incr_sat_value;
        if (incr_sat_value_sig.len() > 0) m_incr_sat_value_sig = incr_sat_value_sig;
      endfunction: add_incr_sat
      
      /* Set incrementing counter threshold value info for this field. */
      function void add_incr_thold(uvm_reg_data_t incr_thold_value, string incr_thold_value_sig = "");
        m_has_incr_thold = 1;
        m_incr_thold_value = incr_thold_value;
        if (incr_thold_value_sig.len() > 0) m_incr_thold_value_sig = incr_thold_value_sig;
      endfunction: add_incr_thold
      
      /* Return the name of the increment input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_incr_signal();
        string incr_signal;
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        if (m_incr_sig.len() > 0) incr_signal = {rdl_reg.get_rdl_name("rg_", 1), m_incr_sig};
        else incr_signal = {rdl_reg.get_rdl_name("h2l_", 1), this.get_name(), "_incr"};
        //$display("---  getting increment signal: %s", incr_signal);
        return incr_signal;
      endfunction: get_incr_signal
      
      /* Return the name of the overflow output signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_overflow_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("l2h_", 1), this.get_name(), "_overflow"};
      endfunction: get_overflow_signal
      
      /* Return the name of the increment saturation output signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_incr_sat_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("l2h_", 1), this.get_name(), "_incrsat_o"};
      endfunction: get_incr_sat_signal
      
      /* Return the name of the increment threshold output signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_incr_thold_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("l2h_", 1), this.get_name(), "_incrthold_o"};
      endfunction: get_incr_thold_signal
      
      /* Return the increment value for this counter field. */
      function uvm_reg_data_t get_incr_value();
        return m_incr_value;
      endfunction: get_incr_value
      
      /* Return the name of the increment value input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_incr_value_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        if (m_incr_value_sig.len() > 0) return rdl_reg.get_rdl_name("rg_", 1, m_incr_value_sig);
        else return {rdl_reg.get_rdl_name("h2l_", 1), this.get_name(), "_incrvalue"};
      endfunction: get_incr_value_signal
      
      /* Return the increment input signal width for this counter field. */
      function int unsigned get_incr_value_signal_width();
        return m_incr_value_sig_width;
      endfunction: get_incr_value_signal_width
      
      /* Return 1 if an increment saturation value/signal is defined for this counter field. */
      function bit has_incr_sat();
        return m_has_incr_sat;
      endfunction: has_incr_sat
      
      /* Return the increment saturation value for this counter field. */
      function uvm_reg_data_t get_incr_sat_value();
        return m_incr_sat_value;
      endfunction: get_incr_sat_value
      
      /* Return the name of the increment saturation value input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_incr_sat_value_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        if (m_incr_sat_value_sig.len() < 1) return "";
        else return rdl_reg.get_rdl_name("rg_", 1, m_incr_sat_value_sig);
      endfunction: get_incr_sat_value_signal
      
      /* Return 1 if an increment threshold value/signal is defined for this counter field. */
      function bit has_incr_thold();
        return m_has_incr_thold;
      endfunction: has_incr_thold
      
      /* Return the increment threshold value for this counter field. */
      function uvm_reg_data_t get_incr_thold_value();
        return m_incr_thold_value;
      endfunction: get_incr_thold_value
      
      /* Return the name of the increment threshold value input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_incr_thold_value_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        if (m_incr_thold_value_sig.len() < 1) return "";
        else return rdl_reg.get_rdl_name("rg_", 1, m_incr_thold_value_sig);
      endfunction: get_incr_thold_value_signal
      
      /* Set decrementing counter info for this field. */
      function void add_decr(uvm_reg_data_t decr_value, string decr_sig = "", string decr_value_sig = "", int unsigned decr_value_sig_width = 0);
        m_is_counter = 1;
        m_decr_value = decr_value;
        if (decr_sig.len() > 0) m_decr_sig = decr_sig;
        if (decr_value_sig.len() > 0) m_decr_value_sig = decr_value_sig;
        m_decr_value_sig_width = decr_value_sig_width;
      endfunction: add_decr
      
      /* Set decrementing counter saturation value info for this field. */
      function void add_decr_sat(uvm_reg_data_t decr_sat_value, string decr_sat_value_sig = "");
        m_has_decr_sat = 1;
        m_decr_sat_value = decr_sat_value;
        if (decr_sat_value_sig.len() > 0) m_decr_sat_value_sig = decr_sat_value_sig;
      endfunction: add_decr_sat
      
      /* Set decrementing counter threshold value info for this field. */
      function void add_decr_thold(uvm_reg_data_t decr_thold_value, string decr_thold_value_sig = "");
        m_has_decr_thold = 1;
        m_decr_thold_value = decr_thold_value;
        if (decr_thold_value_sig.len() > 0) m_decr_thold_value_sig = decr_thold_value_sig;
      endfunction: add_decr_thold
      
      /* Return the name of the decrement input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_decr_signal();
        string decr_signal;
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        if (m_decr_sig.len() > 0) decr_signal = {rdl_reg.get_rdl_name("rg_", 1), m_decr_sig};
        else decr_signal = {rdl_reg.get_rdl_name("h2l_", 1), this.get_name(), "_decr"};
        //$display("---  getting decrement sigmal: %s", decr_signal);
        return decr_signal;
      endfunction: get_decr_signal
      
      /* Return the name of the underflow output signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_underflow_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("l2h_", 1), this.get_name(), "_underflow"};
      endfunction: get_underflow_signal
      
      /* Return the name of the decrement saturation output signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_decr_sat_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("l2h_", 1), this.get_name(), "_decrsat_o"};
      endfunction: get_decr_sat_signal
      
      /* Return the name of the decrement threshold output signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_decr_thold_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("l2h_", 1), this.get_name(), "_decrthold_o"};
      endfunction: get_decr_thold_signal
      
      /* Return the decrement value for this counter field. */
      function uvm_reg_data_t get_decr_value();
        return m_decr_value;
      endfunction: get_decr_value
      
      /* Return the name of the decrement value input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_decr_value_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        if (m_decr_value_sig.len() > 0) return rdl_reg.get_rdl_name("rg_", 1, m_decr_value_sig);
        else return {rdl_reg.get_rdl_name("h2l_", 1), this.get_name(), "_decrvalue"};
      endfunction: get_decr_value_signal
      
      /* Return the decrement input signal width for this counter field. */
      function int unsigned get_decr_value_signal_width();
        return m_decr_value_sig_width;
      endfunction: get_decr_value_signal_width
      
      /* Return 1 if a decrement saturation value/signal is defined for this counter field. */
      function bit has_decr_sat();
        return m_has_decr_sat;
      endfunction: has_decr_sat
      
      /* Return the decrement saturation value for this counter field. */
      function uvm_reg_data_t get_decr_sat_value();
        return m_decr_sat_value;
      endfunction: get_decr_sat_value
      
      /* Return the name of the decrement saturation value input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_decr_sat_value_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        if (m_decr_sat_value_sig.len() < 1) return "";
        else return rdl_reg.get_rdl_name("rg_", 1, m_decr_sat_value_sig);
      endfunction: get_decr_sat_value_signal
      
      /* Return 1 if a decrement threshold value/signal is defined for this counter field. */
      function bit has_decr_thold();
        return m_has_decr_thold;
      endfunction: has_decr_thold
      
      /* Return the decrement threshold value for this counter field. */
      function uvm_reg_data_t get_decr_thold_value();
        return m_decr_thold_value;
      endfunction: get_decr_thold_value
      
      /* Return the name of the decrement threshold value input signal for this field.
       * Note that a signal having this name may not exist in the RTL depending on field options. */
      function string get_decr_thold_value_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        if (m_decr_thold_value_sig.len() < 1) return "";
        else return rdl_reg.get_rdl_name("rg_", 1, m_decr_thold_value_sig);
      endfunction: get_decr_thold_value_signal
      
    endclass : uvm_reg_field_rdl_counter
    
    // interrupt field class 
    class uvm_reg_field_rdl_interrupt extends uvm_reg_field_rdl;
      local string m_intr_sig;
      local int m_intr_level_type = 0;
      local int m_intr_sticky_type = 0;
      local bit m_is_halt = 0;
      local bit m_mask_intr_bits = 0;
      local uvm_reg_field_rdl m_intr_mask_fld;
      local bit m_intr_mask_fld_is_enable;
      local uvm_reg_field_rdl m_halt_mask_fld;
      local bit m_halt_mask_fld_is_enable;
      local uvm_reg_rdl m_cascade_intr_reg;
      local bit m_cascade_reg_is_halt;
      local uvm_vreg_rdl m_associated_vreg;
      
      function new(string name = "uvm_reg_field_rdl_interrupt");
        super.new(name);
      endfunction: new
      
      /* Set interrupt info for this field. */
      function void add_intr(int intr_level_type = 0, int intr_sticky_type = 0, string intr_sig = "", bit mask_intr_bits = 0);
        m_is_interrupt = 1;
        if (intr_level_type > 0) m_intr_level_type = intr_level_type;
        if (intr_sticky_type > 0) m_intr_sticky_type = intr_sticky_type;
        if (intr_sig.len() > 0) m_intr_sig = intr_sig;
        m_mask_intr_bits = mask_intr_bits;
      endfunction: add_intr
      
      /* Return the name of the interrupt input signal for this field. */
      function string get_intr_signal();
        uvm_reg_rdl rdl_reg;
        string intr_signal;
        rdl_reg = this.get_rdl_register();
        if (m_intr_sig.len() > 0) intr_signal = {rdl_reg.get_rdl_name("l2h_", 1), m_intr_sig};
        else intr_signal = {rdl_reg.get_rdl_name("h2l_", 1), this.get_name(), "_intr"};
        //$display("---  getting interrupt signal: %s", intr_signal);
        return intr_signal;
      endfunction: get_intr_signal
      
      /* Return the name of the interrupt output signal for this field's parent register. */
      function string get_intr_out_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("l2h_", 1), "_intr_o"};
      endfunction: get_intr_out_signal
      
      /* Return the interrupt level type for this field.
       *    Values: LEVEL(0), POSEDGE(1), NEGEDGE(2), BOTHEDGE(3) */
      function int get_intr_level_type();
        return m_intr_level_type;
      endfunction: get_intr_level_type
      
      /* Return the interrupt sticky type for this field.
       *    Values: STICKYBIT(0), STICKY(1), NONSTICKY(2) */
      function int get_intr_sticky_type();
        return m_intr_sticky_type;
      endfunction: get_intr_sticky_type
      
      /* Return 1 if the value of this field will be modified by enables/masks. */
      function bit get_mask_intr_bits();
        return m_mask_intr_bits;
      endfunction: get_mask_intr_bits
      
      /* Set indication that this field will contribute to halt. */
      function void add_halt();
        m_is_halt = 1;
      endfunction: add_halt
      
      /* Return 1 if halt is set for this interrupt field. */
      function bit is_halt();
        return m_is_halt;
      endfunction: is_halt
      
      /* Return the name of the halt output signal for this field's parent register. */
      function string get_halt_out_signal();
        uvm_reg_rdl rdl_reg;
        rdl_reg = this.get_rdl_register();
        return {rdl_reg.get_rdl_name("l2h_", 1), "_halt_o"};
      endfunction: get_halt_out_signal
      
      /* Set the uvm_reg_field whose value is used as an intr mask or enable for this interrupt field. */
      function void set_intr_mask_field(uvm_reg_field intr_mask_fld, bit intr_mask_fld_is_enable);
        $cast(m_intr_mask_fld, intr_mask_fld);
        m_intr_mask_fld_is_enable = intr_mask_fld_is_enable;
      endfunction: set_intr_mask_field
      
      /* Return the uvm_reg_field_rdl whose value is used as an intr mask or enable for this interrupt field. */
      function uvm_reg_field_rdl get_intr_mask_field();
        return m_intr_mask_fld;
      endfunction: get_intr_mask_field
      
      /* Return 1 if an intr mask or enable field is assigned for this interrupt field. */
      function bit has_intr_mask_field();
        return (m_intr_mask_fld != null);
      endfunction: has_intr_mask_field
      
      /* Return 1 if an intr enable field is assigned for this interrupt field, otherwise mask is assumed. */
      function bit intr_mask_field_is_enable();
        return m_intr_mask_fld_is_enable;
      endfunction: intr_mask_field_is_enable
      
      /* Return the field value after applying any intr masks/enables. */
      function uvm_reg_data_t get_intr_masked();
        uvm_reg_field_rdl mask_fld;
        if (has_intr_mask_field()) begin
          if (intr_mask_field_is_enable()) return get() & m_intr_mask_fld.get();
          else return get() & ~m_intr_mask_fld.get();
        end
        return get();
      endfunction: get_intr_masked
      
      /* Set the uvm_reg_field whose value is used as an halt mask or enable for this interrupt field. */
      function void set_halt_mask_field(uvm_reg_field halt_mask_fld, bit halt_mask_fld_is_enable);
        $cast(m_halt_mask_fld, halt_mask_fld);
        m_halt_mask_fld_is_enable = halt_mask_fld_is_enable;
      endfunction: set_halt_mask_field
      
      /* Return the uvm_reg_field_rdl whose value is used as an halt mask or enable for this interrupt field. */
      function uvm_reg_field_rdl get_halt_mask_field();
        return m_halt_mask_fld;
      endfunction: get_halt_mask_field
      
      /* Return 1 if a halt mask or enable field is assigned for this interrupt field. */
      function bit has_halt_mask_field();
        return (m_halt_mask_fld != null);
      endfunction: has_halt_mask_field
      
      /* Return 1 if an halt enable field is assigned for this interrupt field, otherwise mask is assumed. */
      function bit halt_mask_field_is_enable();
        return m_halt_mask_fld_is_enable;
      endfunction: halt_mask_field_is_enable
      
      /* Return the field value after applying any halt masks/enables. */
      function uvm_reg_data_t get_halt_masked();
        uvm_reg_field_rdl mask_fld;
        if (has_halt_mask_field()) begin
          if (halt_mask_field_is_enable()) return get() & m_halt_mask_fld.get();
          else return get() & ~m_halt_mask_fld.get();
        end
        return get();
      endfunction: get_halt_masked
      
      /* Set a register whose intr or halt output drives this interrupt field.  This creates an interrupt
       * hierarchy in the model where fields in the specified register are child interrupts of the current field. */
      function void set_cascade_intr_reg(uvm_reg cascade_intr_reg, bit cascade_reg_is_halt);
        $cast(m_cascade_intr_reg, cascade_intr_reg);
        m_cascade_reg_is_halt = cascade_reg_is_halt;
      endfunction: set_cascade_intr_reg
      
      /* Return the uvm_reg_rdl whose intr or halt value drives this interrupt field. */
      function uvm_reg_rdl get_cascade_intr_reg();
        return m_cascade_intr_reg;
      endfunction: get_cascade_intr_reg
      
      /* Return 1 if this interrupt field is driven by a child interrupt register. */
      function bit has_cascade_intr_reg();
        return (m_cascade_intr_reg != null);
      endfunction: has_cascade_intr_reg
      
      /* Return 1 if this interrupt field is driven by a child register's halt (else intr). */
      function bit cascade_reg_is_halt();
        return m_cascade_reg_is_halt;
      endfunction: cascade_reg_is_halt
      
      /* Return all leaf child interrupt fields in this field's interrupt hierarchy. */
      function void get_intr_fields(ref uvm_reg_field fields[$]);
        if (has_cascade_intr_reg()) m_cascade_intr_reg.get_intr_fields(fields);
        else fields.push_back(this);
      endfunction: get_intr_fields
      
      /* Return all leaf child interrupt fields in this field's interrupt hierarchy that.
       * are contributing to an active intr or halt. */
      task get_active_intr_fields(ref uvm_reg_field fields[$], input bit is_halt, input uvm_path_e path = UVM_DEFAULT_PATH);
        if (has_cascade_intr_reg()) m_cascade_intr_reg.get_active_intr_fields(fields, m_cascade_reg_is_halt, path);
        else if (is_halt && (|get_halt_masked())) fields.push_back(this);
        else if (!is_halt && (|get_intr_masked())) fields.push_back(this);
      endtask: get_active_intr_fields
      
      /* Set the uvm_vreg_rdl that is associated with this interrupt field. */
      function void set_associated_vreg(uvm_vreg_rdl associated_vreg);
        m_associated_vreg = associated_vreg;
      endfunction: set_associated_vreg
      
      /* Return the uvm_vreg_rdl that is associated with this interrupt field. */
      function uvm_vreg_rdl get_associated_vreg();
        return m_associated_vreg;
      endfunction: get_associated_vreg
      
      /* Return 1 if a uvm_vreg_rdl is associated with this interrupt field. */
      function bit has_associated_vreg();
        return (m_associated_vreg != null);
      endfunction: has_associated_vreg
      
    endclass : uvm_reg_field_rdl_interrupt
    
    // cbs class for alias register 
    class rdl_alias_reg_cbs extends uvm_reg_cbs;
      uvm_reg  m_alias_regs[$];
      
      function new(string name = "rdl_alias_reg_cbs");
        super.new(name);
      endfunction: new
      
      /* Set alias register group for this callback. */
      function void set_alias_regs(uvm_reg alias_regs[$]);
        m_alias_regs = alias_regs;
      endfunction: set_alias_regs
      
      /* Set all regs in an alias group to same value post r/w */
      task alias_group_predict(input uvm_reg_item rw);
         uvm_reg_data_t 	updated_value;
        if (rw.status != UVM_IS_OK)
          return;
        if (rw.element_kind == UVM_REG) begin
          uvm_reg rg;
          $cast(rg, rw.element);
          if (m_alias_regs[0] != null) begin
            updated_value = rg.get();
            foreach (m_alias_regs[i]) begin
              void'(m_alias_regs[i].predict(updated_value));
              //$display("  new value for %s is %h", m_alias_regs[i].get_full_name(), m_alias_regs[i].get());
            end
          end
        end
      endtask: alias_group_predict
      
      /* Update all regs in an alias group after a read */
      virtual task post_read(input uvm_reg_item rw);
         //$display("*** post_read ***");
         alias_group_predict(rw);
      endtask: post_read
      
      /* Update all regs in an alias group after a write */
      virtual task post_write(input uvm_reg_item rw);
         //$display("*** post_write ***");
         alias_group_predict(rw);
      endtask: post_write
      
      `uvm_object_utils(rdl_alias_reg_cbs)
    endclass : rdl_alias_reg_cbs
    
    // cbs class for enabled/masked intr fields 
    class rdl_mask_intr_field_cbs extends uvm_reg_cbs;
      local uvm_reg_field_rdl_interrupt m_masked_field;
      
      function new(string name = "", uvm_reg_field masked_field = null);
        super.new(name);
        $cast(m_masked_field, masked_field);
      endfunction: new
      
      /* Override post_predict to update value of field according to mask/enable state. */
      virtual function void post_predict(input uvm_reg_field fld, input uvm_reg_data_t previous, inout uvm_reg_data_t value, input uvm_predict_e kind, input uvm_path_e path, input uvm_reg_map map);
        if (kind == UVM_PREDICT_READ) begin
          value = m_masked_field.get_intr_masked();
        end
      endfunction: post_predict
      
      `uvm_object_utils(rdl_mask_intr_field_cbs)
    endclass : rdl_mask_intr_field_cbs
    
    // uvm_reg api mimic class 
    class uvm_reg_mimic;
      protected int unsigned m_index = 0;
      protected int unsigned m_store_index = 0;
      
      function new(int unsigned index);
        m_index = index;
        void'(set_associative_store(1));
      endfunction: new
      
      /* Return the array index of this uvm_reg_mimic. */
      function int get_index();
        return m_index;
      endfunction: get_index
      
      /* Set store index to use associative array store or single store location. */
      function set_associative_store(bit is_associative);
        if (is_associative) m_store_index = m_index;
        else m_store_index = 0;
      endfunction: set_associative_store
      
      /* Return data from this reg's storage location. */
      virtual function uvm_reg_data_t get_field(string fname);
        return 0;
      endfunction: get_field
      
      /* Set data in this reg's storage location. */
      virtual function set_field(string fname, uvm_reg_data_t value);
      endfunction: set_field
      
    endclass : uvm_reg_mimic
    
    // uvm_reg_field api mimic class 
    class uvm_reg_field_mimic;
      local string m_name;
      local uvm_reg_mimic m_parent;
      
      function new(uvm_reg_mimic parent, string name);
        m_parent = parent;
        m_name = name;
      endfunction: new
      
      /* Return field data from this reg's storage location. */
      function uvm_reg_data_t get();
        return m_parent.get_field(m_name);
      endfunction: get
      
      /* Set field data in this reg's storage location. */
      function set(uvm_reg_data_t value);
        void'(m_parent.set_field(m_name, value));
      endfunction: set
      
    endclass : uvm_reg_field_mimic
    
  endpackage
`endif
