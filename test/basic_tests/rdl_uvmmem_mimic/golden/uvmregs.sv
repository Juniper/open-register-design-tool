//   Ordt 190725.01 autogenerated file 
//   Input: ./rdl_uvmmem_mimic/test.rdl
//   Parms: ./rdl_uvmmem_mimic/test.parms
//   Date: Sun Nov 17 17:08:56 EST 2019
//

import uvm_pkg::*;
import ordt_uvm_reg_pkg::*;

// Register sr1
class reg_top_sr1 extends uvm_reg_rdl;
  string m_rdl_tag;
  rand uvm_reg_field_rdl fld1;
  
  function new(string name = "reg_top_sr1");
    super.new(name, 32, UVM_NO_COVERAGE);
  endfunction: new
  
  virtual function void build();
    string rdl_reg_name;
    this.fld1 = new("fld1");
    this.fld1.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.fld1.configure(this, 32, 0, "RW", 0, 32'h0, 1, 1, 1);
    
    rdl_reg_name = get_rdl_name("rg_");
    add_hdl_path_slice({rdl_reg_name, "fld1"}, 0, 32);
  endfunction: build
  
endclass : reg_top_sr1

// Register wr1
class reg_top_wr1 extends uvm_reg_rdl;
  string m_rdl_tag;
  rand uvm_reg_field_rdl fld1;
  rand uvm_reg_field_rdl fld2;
  rand uvm_reg_field_rdl fld3;
  rand uvm_reg_field_rdl fld4;
  rand uvm_reg_field_rdl fld5;
  rand uvm_reg_field_rdl fld6;
  rand uvm_reg_field_rdl fld7;
  rand uvm_reg_field_rdl fld8;
  
  function new(string name = "reg_top_wr1");
    super.new(name, 128, UVM_NO_COVERAGE);
  endfunction: new
  
  virtual function void build();
    string rdl_reg_name;
    this.fld1 = new("fld1");
    this.fld1.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.fld1.configure(this, 16, 0, "RW", 0, 16'h0, 1, 1, 0);
    this.fld2 = new("fld2");
    this.fld2.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.fld2.configure(this, 16, 16, "RW", 0, 16'h0, 1, 1, 0);
    this.fld3 = new("fld3");
    this.fld3.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.fld3.configure(this, 16, 32, "RW", 0, 16'h0, 1, 1, 0);
    this.fld4 = new("fld4");
    this.fld4.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.fld4.configure(this, 16, 48, "RW", 0, 16'h0, 1, 1, 0);
    this.fld5 = new("fld5");
    this.fld5.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.fld5.configure(this, 16, 64, "RW", 0, 16'h0, 1, 1, 0);
    this.fld6 = new("fld6");
    this.fld6.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.fld6.configure(this, 16, 80, "RW", 0, 16'h0, 1, 1, 0);
    this.fld7 = new("fld7");
    this.fld7.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.fld7.configure(this, 16, 96, "RW", 0, 16'h0, 1, 1, 0);
    this.fld8 = new("fld8");
    this.fld8.set_rdl_access_info(1, 1, 1, 0, 0, 0);
    this.fld8.configure(this, 16, 112, "RW", 0, 16'h0, 1, 1, 0);
    
    rdl_reg_name = get_rdl_name("rg_");
    add_hdl_path_slice({rdl_reg_name, "fld1"}, 0, 16);
    add_hdl_path_slice({rdl_reg_name, "fld2"}, 16, 16);
    add_hdl_path_slice({rdl_reg_name, "fld3"}, 32, 16);
    add_hdl_path_slice({rdl_reg_name, "fld4"}, 48, 16);
    add_hdl_path_slice({rdl_reg_name, "fld5"}, 64, 16);
    add_hdl_path_slice({rdl_reg_name, "fld6"}, 80, 16);
    add_hdl_path_slice({rdl_reg_name, "fld7"}, 96, 16);
    add_hdl_path_slice({rdl_reg_name, "fld8"}, 112, 16);
  endfunction: build
  
endclass : reg_top_wr1

// Virtual Register srmem1
class vreg_top_srmem1 extends uvm_vreg_rdl;
  rand uvm_vreg_field fld1;
  
  function new(string name = "vreg_top_srmem1");
    super.new(name, 32);
  endfunction: new
  
  virtual function void build();
    this.fld1 = new("fld1");
    this.fld1.configure(this, 32, 0);
  endfunction: build
  
endclass : vreg_top_srmem1

// Register srmem1
class reg_top_srmem1 extends uvm_reg_mimic;
  local static vreg_top_srmem1 m_vregs;
  local static int unsigned s_last_store_index = 0;
  static uvm_reg_field_mimic fld1;
  
  function new(int unsigned index);
    super.new(index);
  endfunction: new
  
  /* Set static vregs for this register type. */
  static function void set_vreg(vreg_top_srmem1 vregs);
    m_vregs = vregs;
  endfunction: set_vreg
  
  virtual function void build();
    this.fld1 = new(this, "fld1");
  endfunction: build
  
  /* Register read translation class */
  virtual task read(output uvm_status_e status, output uvm_reg_data_t value, input uvm_path_e path = UVM_DEFAULT_PATH);
    m_vregs.read(m_index, status, value, path);
    s_last_store_index = m_store_index;
  endtask: read
  
  /* Register write translation class */
  virtual task write(output uvm_status_e status, input uvm_reg_data_t value, input uvm_path_e path = UVM_DEFAULT_PATH);
    this.set(value);
    this.update(status, path);
  endtask: write
  
  /* Return data from this reg's storage location. */
  virtual function uvm_reg_data_t get();
    s_last_store_index = m_store_index;
    return m_vregs.get_staged(m_store_index);
  endfunction: get
  
  /* Set data in this reg's storage location. */
  virtual function set(uvm_reg_data_t value);
    s_last_store_index = m_store_index;
    m_vregs.set_staged(m_store_index, value);
  endfunction: set
  
  /* Register read into data store */
  virtual task mirror(output uvm_status_e status, input uvm_check_e check = UVM_NO_CHECK, input uvm_path_e path = UVM_DEFAULT_PATH);
    uvm_reg_data_t read_data;
    this.read(status, read_data, path);
    if (check == UVM_CHECK) begin
      uvm_reg_data_t mirror_data = get();
      if (mirror_data !== read_data)
        `uvm_error("RegModel", $sformatf("Memory register %s value read from DUT at index 0x%h (0x%h) does not match mirrored value (0x%h)",
                     m_vregs.get_full_name(), m_index, read_data, mirror_data));
    end
    this.set(read_data);
  endtask: mirror
  
  /* Register write from data_store */
  virtual task update(output uvm_status_e status, input uvm_path_e path = UVM_DEFAULT_PATH);
    m_vregs.write_staged(m_store_index, m_index, status, path);
    s_last_store_index = m_store_index;
  endtask: update
  
  /* Return field data from this reg's storage location. */
  virtual function uvm_reg_data_t get_field(string fname);
    return m_vregs.get_staged_field(s_last_store_index, fname);
  endfunction: get_field
  
  /* Set field data in this reg's storage location. */
  virtual function set_field(string fname, uvm_reg_data_t value);
    m_vregs.stage_field(s_last_store_index, fname, value);
  endfunction: set_field
  
endclass : reg_top_srmem1

// Virtual Register wrmem1
class vreg_top_wrmem1 extends uvm_vreg_rdl;
  rand uvm_vreg_field fld1;
  rand uvm_vreg_field fld2;
  rand uvm_vreg_field fld3;
  rand uvm_vreg_field fld4;
  rand uvm_vreg_field fld5;
  rand uvm_vreg_field fld6;
  rand uvm_vreg_field fld7;
  rand uvm_vreg_field fld8;
  
  function new(string name = "vreg_top_wrmem1");
    super.new(name, 128);
  endfunction: new
  
  virtual function void build();
    this.fld1 = new("fld1");
    this.fld1.configure(this, 16, 0);
    this.fld2 = new("fld2");
    this.fld2.configure(this, 16, 16);
    this.fld3 = new("fld3");
    this.fld3.configure(this, 16, 32);
    this.fld4 = new("fld4");
    this.fld4.configure(this, 16, 48);
    this.fld5 = new("fld5");
    this.fld5.configure(this, 16, 64);
    this.fld6 = new("fld6");
    this.fld6.configure(this, 16, 80);
    this.fld7 = new("fld7");
    this.fld7.configure(this, 16, 96);
    this.fld8 = new("fld8");
    this.fld8.configure(this, 16, 112);
  endfunction: build
  
endclass : vreg_top_wrmem1

// Register wrmem1
class reg_top_wrmem1 extends uvm_reg_mimic;
  local static vreg_top_wrmem1 m_vregs;
  local static int unsigned s_last_store_index = 0;
  static uvm_reg_field_mimic fld1;
  static uvm_reg_field_mimic fld2;
  static uvm_reg_field_mimic fld3;
  static uvm_reg_field_mimic fld4;
  static uvm_reg_field_mimic fld5;
  static uvm_reg_field_mimic fld6;
  static uvm_reg_field_mimic fld7;
  static uvm_reg_field_mimic fld8;
  
  function new(int unsigned index);
    super.new(index);
  endfunction: new
  
  /* Set static vregs for this register type. */
  static function void set_vreg(vreg_top_wrmem1 vregs);
    m_vregs = vregs;
  endfunction: set_vreg
  
  virtual function void build();
    this.fld1 = new(this, "fld1");
    this.fld2 = new(this, "fld2");
    this.fld3 = new(this, "fld3");
    this.fld4 = new(this, "fld4");
    this.fld5 = new(this, "fld5");
    this.fld6 = new(this, "fld6");
    this.fld7 = new(this, "fld7");
    this.fld8 = new(this, "fld8");
  endfunction: build
  
  /* Register read translation class */
  virtual task read(output uvm_status_e status, output uvm_reg_data_t value, input uvm_path_e path = UVM_DEFAULT_PATH);
    m_vregs.read(m_index, status, value, path);
    s_last_store_index = m_store_index;
  endtask: read
  
  /* Register write translation class */
  virtual task write(output uvm_status_e status, input uvm_reg_data_t value, input uvm_path_e path = UVM_DEFAULT_PATH);
    this.set(value);
    this.update(status, path);
  endtask: write
  
  /* Return data from this reg's storage location. */
  virtual function uvm_reg_data_t get();
    s_last_store_index = m_store_index;
    return m_vregs.get_staged(m_store_index);
  endfunction: get
  
  /* Set data in this reg's storage location. */
  virtual function set(uvm_reg_data_t value);
    s_last_store_index = m_store_index;
    m_vregs.set_staged(m_store_index, value);
  endfunction: set
  
  /* Register read into data store */
  virtual task mirror(output uvm_status_e status, input uvm_check_e check = UVM_NO_CHECK, input uvm_path_e path = UVM_DEFAULT_PATH);
    uvm_reg_data_t read_data;
    this.read(status, read_data, path);
    if (check == UVM_CHECK) begin
      uvm_reg_data_t mirror_data = get();
      if (mirror_data !== read_data)
        `uvm_error("RegModel", $sformatf("Memory register %s value read from DUT at index 0x%h (0x%h) does not match mirrored value (0x%h)",
                     m_vregs.get_full_name(), m_index, read_data, mirror_data));
    end
    this.set(read_data);
  endtask: mirror
  
  /* Register write from data_store */
  virtual task update(output uvm_status_e status, input uvm_path_e path = UVM_DEFAULT_PATH);
    m_vregs.write_staged(m_store_index, m_index, status, path);
    s_last_store_index = m_store_index;
  endtask: update
  
  /* Return field data from this reg's storage location. */
  virtual function uvm_reg_data_t get_field(string fname);
    return m_vregs.get_staged_field(s_last_store_index, fname);
  endfunction: get_field
  
  /* Set field data in this reg's storage location. */
  virtual function set_field(string fname, uvm_reg_data_t value);
    m_vregs.stage_field(s_last_store_index, fname, value);
  endfunction: set_field
  
endclass : reg_top_wrmem1

// Base block
class block_top extends uvm_reg_block_rdl;
  rand reg_top_sr1 sr1;
  rand reg_top_wr1 wr1;
  rand reg_top_sr1 sr_repeat1;
  rand reg_top_sr1 sr_repeat2;
  rand reg_top_sr1 sr_repeat3;
  rand uvm_mem MEM_srmem1;
  rand vreg_top_srmem1 VREGS_srmem1;
  rand reg_top_srmem1 srmem1 [100];
  rand uvm_mem MEM_wrmem1;
  rand vreg_top_wrmem1 VREGS_wrmem1;
  rand reg_top_wrmem1 wrmem1 [300];
  
  function new(string name = "block_top");
    super.new(name);
  endfunction: new
  
  virtual function void build();
    this.default_map = create_map("", `UVM_REG_ADDR_WIDTH'h0, 16, UVM_LITTLE_ENDIAN, 1);
    this.set_rdl_address_map(1);
    this.set_rdl_address_map_hdl_path({`TOP_PIO_INSTANCE_PATH, ".pio_logic"});
    this.sr1 = new("sr1");
    this.sr1.configure(this, null, "");
    this.sr1.set_rdl_tag("sr1_");
    this.sr1.set_reg_test_info(0, 0, 0);
    this.sr1.build();
    this.default_map.add_reg(this.sr1, `UVM_REG_ADDR_WIDTH'h0, "RW", 0);
    this.wr1 = new("wr1");
    this.wr1.configure(this, null, "");
    this.wr1.set_rdl_tag("wr1_");
    this.wr1.set_reg_test_info(0, 0, 0);
    this.wr1.build();
    this.default_map.add_reg(this.wr1, `UVM_REG_ADDR_WIDTH'h100, "RW", 0);
    this.sr_repeat1 = new("sr_repeat1");
    this.sr_repeat1.configure(this, null, "");
    this.sr_repeat1.set_rdl_tag("sr_repeat1_");
    this.sr_repeat1.set_reg_test_info(0, 0, 0);
    this.sr_repeat1.build();
    this.default_map.add_reg(this.sr_repeat1, `UVM_REG_ADDR_WIDTH'h200, "RW", 0);
    this.sr_repeat2 = new("sr_repeat2");
    this.sr_repeat2.configure(this, null, "");
    this.sr_repeat2.set_rdl_tag("sr_repeat2_");
    this.sr_repeat2.set_reg_test_info(0, 0, 0);
    this.sr_repeat2.build();
    this.default_map.add_reg(this.sr_repeat2, `UVM_REG_ADDR_WIDTH'h204, "RW", 0);
    this.sr_repeat3 = new("sr_repeat3");
    this.sr_repeat3.configure(this, null, "");
    this.sr_repeat3.set_rdl_tag("sr_repeat3_");
    this.sr_repeat3.set_reg_test_info(0, 0, 0);
    this.sr_repeat3.build();
    this.default_map.add_reg(this.sr_repeat3, `UVM_REG_ADDR_WIDTH'h208, "RW", 0);
    this.MEM_srmem1 = new("MEM_srmem1", 100, 32);
    this.MEM_srmem1.configure(this);
    this.VREGS_srmem1 = new;
    this.VREGS_srmem1.configure(this, MEM_srmem1, 100);
    this.VREGS_srmem1.set_reset_value(32'h0);
    this.VREGS_srmem1.set_reg_test_info(0, 0, 0);
    this.VREGS_srmem1.build();
    reg_top_srmem1::set_vreg(VREGS_srmem1);
    for (int unsigned i=0 ; i<100; i++) begin
      this.srmem1[i] = new(i);
    end
    this.default_map.add_mem(this.MEM_srmem1, `UVM_REG_ADDR_WIDTH'h2000);
    this.MEM_wrmem1 = new("MEM_wrmem1", 300, 128);
    this.MEM_wrmem1.configure(this);
    this.VREGS_wrmem1 = new;
    this.VREGS_wrmem1.configure(this, MEM_wrmem1, 300);
    this.VREGS_wrmem1.set_reset_value(128'h0);
    this.VREGS_wrmem1.set_reg_test_info(0, 0, 0);
    this.VREGS_wrmem1.build();
    reg_top_wrmem1::set_vreg(VREGS_wrmem1);
    for (int unsigned i=0 ; i<300; i++) begin
      this.wrmem1[i] = new(i);
    end
    this.default_map.add_mem(this.MEM_wrmem1, `UVM_REG_ADDR_WIDTH'h20000);
    this.add_callbacks();
  endfunction: build
  
  `uvm_object_utils(block_top)
endclass : block_top
