#   Ordt 190725.01 autogenerated file 
#   Input: ./js_basic_01/test.js
#   Parms: ./js_basic_01/test.parms
#   Date: Sun Nov 17 17:09:22 EST 2019
#


from enum import Enum, auto

class ordt_drv_error(Enum):
    BAD_TAG = auto()
    BAD_PATH = auto()
    BAD_ADDRESS = auto()

class ordt_drv_return_type(Enum):
    REG = auto()
    REGSET = auto()
    FIELD = auto()

class ordt_drv_path_element:
    
    def __init__(self, name_str):
            sub_lst = name_str.split('[')
            if len(sub_lst)==2:
                self.name = sub_lst[0]
                self.idx = sub_lst[1].rstrip(']')
            else:
                self.name = name_str
                self.idx = 1
    

class ordt_drv_field:
    
    def __init__(self, name, loidx, width, readable, writeable, reset):
        self.name = name
        self.loidx = loidx
        self.width = width
        self.readable = readable
        self.writeable = writeable
        self.reset = reset
    

class ordt_drv_element:
    ORDT_PIO_DRV_VERBOSE = True
    
    def __init__(self, name):
        self.name = name
    
    def get_address_using_version(self, version, pathstr, address_in):
        path = self.get_pathlist(pathstr)
        if path:
            return self.get_address_using_list(version, path, False, address_in)
        if __class__.ORDT_PIO_DRV_VERBOSE:
            print('--> invalid path: ' + pathstr)
        return {'error':ordt_drv_error.BAD_PATH}
    
    def get_path_instance_list_using_version(self, version, pathstr, path_instance_list_in):
        path = self.get_pathlist(pathstr)
        if path:
            return self.get_path_instance_list_using_list(version, path, False, path_instance_list_in)
        if __class__.ORDT_PIO_DRV_VERBOSE:
            print('--> invalid path: ' + pathstr)
        return {'error':ordt_drv_error.BAD_PATH}
    
    def get_version(self, tag):
        if tag == 'simple1':
            return 0
        else:
            return -1
    
    def get_tags(self):
        tags = []
        tags.append('simple1')
        return tags
    
    def get_address_using_tag(self, tag, pathstr, address_in):
        version = self.get_version(tag)
        if version<0:
            if __class__.ORDT_PIO_DRV_VERBOSE:
                print('--> invalid tag: ' + tag)
            return {'error':ordt_drv_error.BAD_TAG}
        return self.get_address_using_version(version, pathstr, address_in)
    
    def get_path_instance_list_using_tag(self, tag, pathstr, path_instance_list_in):
        version = self.get_version(tag)
        if version<0:
            if __class__.ORDT_PIO_DRV_VERBOSE:
                print('--> invalid tag: ' + tag)
            return {'error':ordt_drv_error.BAD_TAG}
        return self.get_path_instance_list_using_version(version, pathstr, path_instance_list_in)
    
    def get_pathlist(self, pathstr):
        pathlist = []
        lst = pathstr.split('.')
        for str_elem in lst:
            path_elem = ordt_drv_path_element(str_elem)
            pathlist.append(path_elem)
        return pathlist
    
    def get_path_using_tag(self, tag, address, path_in):
        version = self.get_version(tag)
        if version<0:
            if __class__.ORDT_PIO_DRV_VERBOSE:
                print('--> invalid tag: ' + tag)
            return {'error':ordt_drv_error.BAD_TAG}
        return self.get_path_using_version(version, address, path_in)
    

class ordt_drv_regset_child:
    
    def __init__(self, version_map, child, reps, offset, stride):
        self.version_map = version_map
        self.child = child
        self.reps = reps
        self.offset = offset
        self.stride = stride
    
    def find_offset(self, address_in):
        if not self.stride:
            return (0, self.child.name)
        if (address_in < self.offset) or (address_in >= self.offset + self.reps*self.stride):
            return (0, None)
        if self.reps < 2:
            return (self.offset, '.' + self.child.name)
        index = (address_in - self.offset) // self.stride
        return (self.offset + index*self.stride, '.' + self.child.name + '[' + str(index) + ']')
    

class ordt_drv_regset(ordt_drv_element):
    
    def __init__(self, name):
        super().__init__(name)
        self.children = []
    
    def get_address_using_list(self, version, path, bypass_names, address_in):
        if not path:
            return {'error':ordt_drv_error.BAD_PATH}
        pelem = path[0]
        if not bypass_names:
            path.pop(0)
            if not path:
                return {'type':ordt_drv_return_type.REGSET, 'address':address_in, 'children':self.get_child_names(version)}
            pelem = path[0]
        for child in self.children:
            if ((1<<version) & child.version_map) and (bypass_names or (pelem.name == child.child.name)):
                address = address_in + child.offset
                if child.reps > 1:
                    address += child.stride*int(pelem.idx)
                return child.child.get_address_using_list(version, path, False, address)
        if __class__.ORDT_PIO_DRV_VERBOSE:
            print('--> unable to find child ' + pelem.name + ' in regset ' + self.name)
        return {'error':ordt_drv_error.BAD_PATH}
    
    def get_path_instance_list_using_list(self, version, path, bypass_names, path_instance_list_in):
        if not path:
            return {'error':ordt_drv_error.BAD_PATH}
        pelem = path[0]
        if not bypass_names:
            path.pop(0)
            if not path:
                return {'type':ordt_drv_return_type.REGSET, 'instances':path_instance_list_in}
            pelem = path[0]
        for child in self.children:
            if ((1<<version) & child.version_map) and (bypass_names or (pelem.name == child.child.name)):
                path_instance_list = path_instance_list_in.copy()
                path_instance_list.append(child)
                return child.child.get_path_instance_list_using_list(version, path, False, path_instance_list)
        if __class__.ORDT_PIO_DRV_VERBOSE:
            print('--> unable to find child ' + pelem.name + ' in regset ' + self.name)
        return {'error':ordt_drv_error.BAD_PATH}
    
    def add_child(self, version_map, child, reps, offset, stride):
        new_child = ordt_drv_regset_child(version_map, child, reps, offset, stride)
        self.children.append(new_child)
    
    def get_child_names(self, version):
        childnames = []
        for child in self.children:
            if (1<<version) & child.version_map:
                childnames.append(child.child.name)
        return childnames
    
    def get_path_using_version(self, version, address_in, path_in):
        for child in self.children:
            if (1<<version) & child.version_map:
                (match_addr, match_path) = child.find_offset(address_in)
                if match_path:
                    return child.child.get_path_using_version(version, address_in - match_addr, path_in + match_path)
        return {'error':ordt_drv_error.BAD_ADDRESS}
    

class ordt_drv_reg(ordt_drv_element):
    
    def __init__(self, name, width):
        super().__init__(name)
        self.fields = []
        self.width = width
    
    def get_address_using_list(self, version, path, bypass_names, address_in):
        if not path:
            return {'error':ordt_drv_error.BAD_PATH}
        path.pop(0)
        if not path:
            return {'type':ordt_drv_return_type.REG, 'address':address_in, 'width':self.width, 'fields':self.fields}
        if __class__.ORDT_PIO_DRV_VERBOSE:
            pelem = path[0]
            print('--> invalid child ' + pelem.name + ' specified in reg ' + self.name)
        return {'error':ordt_drv_error.BAD_PATH}
    
    def get_path_instance_list_using_list(self, version, path, bypass_names, path_instance_list_in):
        if not path:
            return {'error':ordt_drv_error.BAD_PATH}
        path.pop(0)
        if not path:
            return {'type':ordt_drv_return_type.REG, 'instances':path_instance_list_in}
        if len(path) == 1:
            fname = path[0].name
            fld = self.get_field_by_name(fname)
            if fld:
                path_instance_list = path_instance_list_in.copy()
                path_instance_list.append(fld)
                return {'type':ordt_drv_return_type.FIELD, 'instances':path_instance_list}
        if __class__.ORDT_PIO_DRV_VERBOSE:
            pelem = path[0]
            print('--> invalid child ' + pelem.name + ' specified in reg ' + self.name)
        return {'error':ordt_drv_error.BAD_PATH}
    
    def get_field_by_name(self, name):
        for fld in self.fields:
            if fld.name == name:
                return fld
    
    def add_field(self, name, loidx, width, readable, writeable, reset):
        new_field = ordt_drv_field(name, loidx, width, readable, writeable, reset)
        self.fields.append(new_field)
    
    def get_path_using_version(self, version, address_in, path_in):
        return {'type':ordt_drv_return_type.REG, 'path':path_in}
    

class ordt_drv_root(ordt_drv_regset):
    base_address = 0
    
    def __init__(self):
        super().__init__('root')
        self.build()
    
    def build(self):
        log_address2_21 = ordt_drv_reg('log_address2', 32)
        log_address2_21.add_field('value', 0, 10, True, True, 0)
        wide_reg_22 = ordt_drv_reg('wide_reg', 128)
        wide_reg_22.add_field('value', 0, 96, True, True, 51265281626876924325234320805)
        disable_check_18 = ordt_drv_reg('disable_check', 32)
        disable_check_18.add_field('timer_sram', 0, 1, True, True, 0)
        disable_check_18.add_field('cbuf_fifo', 1, 1, True, True, 0)
        disable_check_18.add_field('lut_st', 2, 1, True, True, 0)
        disable_check_18.add_field('l0_b0', 3, 1, True, True, 0)
        disable_check_18.add_field('l0_b1', 4, 1, True, True, 0)
        disable_check_18.add_field('l0_b2', 5, 1, True, True, 0)
        disable_check_18.add_field('l0_b3', 6, 1, True, True, 0)
        features_19 = ordt_drv_reg('features', 32)
        features_19.add_field('adr_logged', 0, 1, True, False, 1)
        features_19.add_field('correctable', 1, 1, True, False, 0)
        features_19.add_field('checker', 2, 1, True, False, 1)
        features_19.add_field('generator', 3, 1, True, False, 1)
        features_19.add_field('wdth', 4, 5, True, False, 7)
        features_19.add_field('syn_logged', 9, 1, True, False, 0)
        features_19.add_field('version', 30, 2, True, False, 2)
        log_address1_20 = ordt_drv_reg('log_address1', 32)
        log_address1_20.add_field('value', 0, 10, True, True, 0)
        stats_17 = ordt_drv_regset('stats')
        stats_17.add_child(1, log_address2_21, 1, 272, 4)
        stats_17.add_child(1, wide_reg_22, 1, 288, 16)
        stats_17.add_child(1, disable_check_18, 2, 0, 4)
        stats_17.add_child(1, features_19, 1, 256, 4)
        stats_17.add_child(1, log_address1_20, 1, 260, 4)
        extra_reg_31 = ordt_drv_reg('extra_reg', 32)
        extra_reg_31.add_field('value', 0, 32, True, True, None)
        reorder_window_24 = ordt_drv_reg('reorder_window', 32)
        reorder_window_24.add_field('size', 0, 11, True, True, 128)
        reorder_window_24.add_field('set_back', 16, 11, True, True, 16)
        reorder_window_24.add_field('ws_enable', 31, 1, True, True, 1)
        buffer_27 = ordt_drv_reg('buffer', 32)
        buffer_27.add_field('addr1', 0, 11, True, False, None)
        buffer_27.add_field('addr0', 16, 11, True, False, None)
        cp_fp_wr_26 = ordt_drv_regset('cp_fp_wr')
        cp_fp_wr_26.add_child(1, buffer_27, 4, 0, 4)
        roll32_counter_reg_28 = ordt_drv_reg('roll32_counter_reg', 32)
        roll32_counter_reg_28.add_field('count', 0, 4, True, True, 0)
        rcnt_sat_log_30 = ordt_drv_reg('rcnt_sat_log', 32)
        rcnt_sat_log_30.add_field('count', 0, 16, True, True, 0)
        rcnt_sat_log_30.add_field('str', 16, 10, True, True, 0)
        rcnt_sat_log_30.add_field('subch', 26, 5, True, True, 0)
        rcnt_sat_log_30.add_field('en', 31, 1, True, True, 1)
        sat32_counter_reg_29 = ordt_drv_reg('sat32_counter_reg', 32)
        sat32_counter_reg_29.add_field('count', 0, 4, True, True, 0)
        stream_reconf_25 = ordt_drv_reg('stream_reconf', 32)
        stream_reconf_25.add_field('stream', 0, 10, True, True, 0)
        stream_reconf_25.add_field('busy', 16, 1, True, False, 0)
        rdr_23 = ordt_drv_regset('rdr')
        rdr_23.add_child(1, reorder_window_24, 1, 0, 4)
        rdr_23.add_child(1, cp_fp_wr_26, 1, 8640, 16)
        rdr_23.add_child(1, roll32_counter_reg_28, 1, 8656, 4)
        rdr_23.add_child(1, rcnt_sat_log_30, 1, 8664, 4)
        rdr_23.add_child(1, sat32_counter_reg_29, 1, 8660, 4)
        rdr_23.add_child(1, stream_reconf_25, 1, 4, 4)
        simple1_16 = ordt_drv_regset('simple1')
        simple1_16.add_child(1, stats_17, 1, 4096, 512)
        simple1_16.add_child(1, extra_reg_31, 1, 25052, 4)
        simple1_16.add_child(1, rdr_23, 1, 16384, 16384)
        self.add_child(1, simple1_16, 1, 0, 0)
    
    def get_address_using_version(self, version, pathstr, address_in):
        path = self.get_pathlist(pathstr)
        if path:
            return self.get_address_using_list(version, path, True, address_in)
        if __class__.ORDT_PIO_DRV_VERBOSE:
            print('--> invalid path: ' + pathstr)
        return {'error':ordt_drv_error.BAD_PATH}
    
    def get_path_instance_list_using_version(self, version, pathstr, path_instance_list_in):
        path = self.get_pathlist(pathstr)
        if path:
            return self.get_path_instance_list_using_list(version, path, True, path_instance_list_in)
        if __class__.ORDT_PIO_DRV_VERBOSE:
            print('--> invalid path: ' + pathstr)
        return {'error':ordt_drv_error.BAD_PATH}
    
    def get_address(self, tag, pathstr):
        '''return address given a path string and tag'''
        return self.get_address_using_tag(tag, pathstr, __class__.base_address)
    
    def get_path_instance_list(self, tag, pathstr):
        '''return list of model elements given a path string and tag'''
        return self.get_path_instance_list_using_tag(tag, pathstr, [])
    
    def get_path(self, tag, address):
        '''return path string given an address and tag'''
        return self.get_path_using_tag(tag, address, '')
    

